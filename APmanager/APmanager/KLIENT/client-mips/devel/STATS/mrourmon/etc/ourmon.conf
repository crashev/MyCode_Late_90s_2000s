# sample /etc/ourmon.conf file
# edit filters as desired.
# note that filter examples are in rough order:
# note that ALL existing front-end filters are documented in here.
#
#	1. hardwired
#	2. topn
#	3. bpf
#
#######################################################################
# HARDWIRED
#######################################################################
# default bpf pkts count/drop filter cannot be removed
# It shows counts/drops acc. to kernel BPF
# It CAN support two interfaces on the same probe, as
# the front-end probe can take two interfaces 
# uses RRDTOOL

# the pkts filter (counts/drops) cannot be configured out
# However, a system label can be optionally put in
# as a way to allow multiple front-end probes to have
# their individual pkts filter/graphs kept separate by the back-end.
# Thus for example one front-end probe can do bpfs
# and the other can do topn and the rest.
# Both can also have their own pkts filters.
# With one shared graphical back-end!.
# If you have only one front-end probe, you do not need it.
# Probably doesn't hurt to use it though.
# the probename should be a simple name like "topper"

#sysname probename

# fixed_ipproto tcp udp icmp xtra (other)
# displays byte counts for tcp vs udp vs icmp vs none-of-those.
# if you want pkt count use bpf
# uses RRDTOOL
fixed_ipproto

#
# fixed_tcp3 ... two tcp server ports to watch, email and web
# xtra (traffic not matching) is also shown.
# uses RRDTOOL
fixed_tcp3	25	80

# fixed_iprange1 is old and crufty and one should better
# use the user-bpf mechanism here.  It allows traffic between
# two networks (ip src and ip dst must both mention one of the two nets)
# syntax is:  ip_net1 netmask ip_net2 netmask net1label net2label
# Thus you can see how much traffic goes between those two networks
# compared to the rest of the traffic.  
# uses RRDTOOL
# fixed_iprange1  10.1.0.0  255.255.0.0 10.2.0.0 255.255.0.0 tonynet yakovnet

# L2 multicast broadcast unicast, use exactly this syntax.
# This filter counts bytes for L2 broadcast/multicast/unicast dst addresses
# Leave the ip/netmask alone.  They do not need to be changed.
# uses RRDTOOL
fixed_cast  127.0.0.0 255.0.0.0

# this filter displays the size of packets in 4 buckets
# <= 100, <=500, <=1000, <=1500.  L2 size included.
# uses RRDTOOL
fixed_size

######################################################################
# TOP N filters
#
# this includes traditional topn (biggest flows) and many new top 
# lists that are aimed at catching various scanning attacks and DOS 
# attacks.
######################################################################
# topN filters.  best NOT to change the number unless
# you want to do some real debugging.  
# uses drawtopn/histogram drawing program.
# note: there are four graphs here, topn_ip (all ip flows),
# tcp, udp, and icmp flows.  topn_ip (all flows) includes
# xtra; i.e., it shows the remaining non top traffic byte count.
# The other three (tcp/udp/icmp) do not show xtra and only show
# the top traffic in their category.  
# The flow-id is paired with the byte count for that flow during
# the sample period expressed in bits/second.
#
# In addition to the 4 histograms, topn also produces two kinds
# of metadata graphed by omupdate.pl.  This includes
# 1. flow count (RRDTOOL graph), the number of flows of each kind
# is graphed.  This can be useful for detecting DOS and scanning attacks.
# This is because since a flow is simply defined as a unique tuple
# (ip src, ip dst, proto, L4 src port, L4 dst port), a worm may
# generate many ip destinations (or ports), and hence may greatly
# increase the number of flows from normal in a category.  Hence
# using RRD here to baseline data is extremely useful in terms of
# anamoly detection.
# 2. insert graphing.  The # of inserts (mallocs) is graphed as well.
# This is also useful for detecting anomalous flows as unique tuples
# with no matches will drive up the number of total inserts.
# This is an indication that the flow hashing algorithm is failing
# in terms of lookups, and is being driven to extremis in terms of
# failed lookups (all inserts, no matches).  It is possible
# you should check syslog to see if ourmon has reported malloc failures.
# ourmon will not exit on a malloc failure but if it runs out of memory,
# obviousally things are not good.
#
# The number of graphs should be set as follows: range 10..100 by 10s. 
# 60 will produce 6 graphs.

topn_ip   60

# topn port filters.  numbers may be 10, 20, 30 ... 100
# This filter reports the top TCP and UDP ports in terms
# of bytes used by that port. It also includes counts of whether the
# port was seen as the source port or the destination port.
# Two lists, tcp and udp top ports are produced.  
#
# This topn port filter helps you to determine which ports are actually
# being used.  E.g., bittorrent uses ports 6881..6999.
# uses drawtopn/histogram drawing program.
topn_port 20	

# topn tcp syn list:
# N should be a multiple of 10, 10..100.  N is the top N TCP
# syn senders.  A list of ip source addresses is kept.  For each ip
# address we count the number of syn packets where the ip address
# is the source.  We sort on this count.  In addition, we count 
# the number of fins seen where the ip address is considered as the
# destination address (sent back to the syn sender).  
# Resets are also counted, for resets the ip destination
# is the target ip.  Thus we are considering the number of syns and fins
# a given IP sends, and also the number of resets a given IP receives.
# The output thus shows syn, fin, and reset counts.  
# We also count the total number of TCP packets sent in both directions.
# We compute a weight that is basically syns+fins+rsts/total tcp pkts.
# We sort on syns at this time and simply present fins/resets/total/weight as information.
# Note: all syns, few fins, and many resets should be regarded as a likely
# worm or hostile scan.  all syns and many fins may be a P2P app. 
# However that said, we have found that P2P app weights are generally less
# than 30% (gnutella is worst case scenario, followed by kazaa).  
# We suggest that a weight of 80% or more is highly likely to be a scanner.
#
# Two additional functions are also presented here.  
# If topn_syn_wormfile is supplied, a file named "tcpworm.txt" will be
# created in the supplied directory.  This file contains a list of ip source
# addresses that have satisfied the following constraint:
#
# sins - fins > 20.  
#
# tcpworm.txt is processed at this time by the backend, via the tcpworm.pl script.
# In addition, topn_syn_homeip can be supplied with a IP address/netmask pair
# that are presumed to be your ip address/range.  If this is done,
# a RRDTOOL graph is created by the backend, which counts the total # of entries
# in the tcpworm.txt file, and also counts them as belonging to
# the supplied address/mask range ("us") or not ("them").  This can be useful
# in determining if a large-scale possibly distributed syn scanning attack is occuring.
#
# tworm_weight is used in the tworm graph to determine the count of "worms"
# we set it to 0 as a default.  If you want to limit the "worm count"
# to those ip sources having a work weight of 80% or more set it to 80.

topn_syn 60
topn_syn_wormfile /home/mrourmon/tmp
# important: set the IPs here to something useful (your internal net/mask)
topn_syn_homeip  10.1.0.0	255.255.0.0
#tworm_weight 80

# undocumented but an auto trigger is lurking
# it needs more testing
# the config meaning is
#	    threshold for trigger  #pkts to store   where to store pkt dump file
# For example, if the tworm total count is > 100 store 1 million packets in
# a file that has the form  tworm.<timestamp>.dmp.
#	  
# trigger_worm 100 1000000 /home/mrourmon/dumps

# topn_icmperror generates separate topn lists for udp senders
# and hosts receiving a great number of icmp errors.
# In the mon.lite file these lists are called 
# icmperror_list:
# udperror_list:
#
# The icmperror_list shows hosts sorted by the max icmp errors they
# received during the sample period.  ICMP errors are the sum
# of ICMP unreachables, TTL exceeded, or ICMP redirects.  
# In addition in an attempt to give you some notion as to what
# the host is doing, we also show counts to indicate whether the
# host is sending TCP, UDP, or ICMP ping packets.  The theory here
# is that a host that is scanning may well generate a great number of
# ICMP errors (especially UDP scanners).
#
# topn_icmperror also generates a UDP error list as a side effect.
# This list sorts on a weighted metric that is basically:
# UDP pkts sent - UDP packets received * ICMP errors.
#
# Pkts sent and pkts received as well as total ICMP errors
# (unreachables, ttl exceeded, redirects) are shown.  It should
# be pointed out that a system sending MANY udp packets, with
# few returned, plus a number of ICMP errors ... is probably
# a UDP scanner.
#
# note: this also includes a udpreport.txt with port signatures
# similar to the portreport.txt produced by the topn_syn filter.
 
topn_icmperror 40

# we also have a conventional IP scanner list mechanism.
# topn_scans shows the top IP scanners in terms of a single IP source
# to many IP destinations.  We sort on the number of distinct IP destinations.
# At this time, the number of graphs as usual can vary from 10..100 by 10s.
# This will be fixed in a future release
topn_scans 20

# topn_port_scans produces 3 outputs.  It shows the top N port scanners.
# We sort on the max. number of distinct L4 (UDP/TCP) destination ports.
# There are 3 outputs.
# top IP port scans shows combined L4 TCP/UDP numbers (we just count the ports,
# but do not distinguish TCP from UDP)
# Top UDP and TCP port scans show IP source addresses focusing on UDP and TCP
# respectively.
# At this time, the number of graphs as usual can vary from 10..100 by 10s.
topn_port_scans 20

########################################################################
# user customizable bpf graphs.
########################################################################
#
# nine example user-mode bpf filters sets.
#
# Some are commented out by default.  Some are commented in.
# This mechanism allows general RRDTOOL graphs to be constructed with
# 4-6 lines (or less) per graph, and one bpf expression per line.
#
# general syntax for a BPF filter-set:
# bpf (start rrdtool graph), graph label, line label, bpf filter-spec
# bpf-next (add to previous rrdtool graph), line label, bpf filter-spec
# bpf-next ... (up to 4)
#
# There are two ways to terminate a BPF filter-set graph:
# 1. start another graph (e.g., use bpf) or no more commands or some
#	other command
# 2. bpf-noxtra - suppress extra byte counts field.  It will still
# appear in the graph, but should have a zero value.
# Note: sometimes will want it.  Sometimes you will not want it.
#
# In addition: the bpf graph mechanism defaults to counting bytes in the total
# packet and the back-end represents this as bits/sec.  (Even though
# the front-end counts bytes/sec).  However if you want, you can toggle
# the bpf declarations to counting packets (pkts/sec), as opposed to
# bytes.  This is done with a global config statement (can appear
# anywhere in the config file).
#
# bpf-packets 
#
# Note that this must appear before the bpf statement that starts
# a graph.  Once uttered it remains true for any/all bpf graphs
# that follow it.  E.g., 
#
# bpf-packets
# bpf "graph1"
# ...
# bpf "graph2"
#
# would both be graphed as packets/sec.  
#
# bpf-bytes 
#
# is the global config statement for putting bpf graphs back into
# their default bytes (bits/sec) representation.  
#
# E.g,
# bpf-packets
# bpf "graph1" etc...
# bpf-bytes
# bpf "graph2" etc...
#
# would mean that graph1 graphs packets and graph2 graphs bits/sec.

# bpf graph examples
# example 1: bpf neighbors (chart some neighbor ips both in/out)
#bpf "subnets1" "neighbor1" "net 10.0.0.0/8"
#bpf-next "neighbor2" "net 11.0.0.0/8"
# leave off extra, else remainder bytes put in
#bpf-next "neighbor3" "net 12.0.0.0/8"
# leave off extra, else remainder bytes put in
#bpf-noxtra

# example 2: do something similar to the hardwired ip proto filter.
# note: we want extra on this one, just in case there is something
# that is not tcp/udp/icmp.
# We also want to count packets, not bytes (which
# TCP/UDP/ICMP expressed as bpf filter:
#bpf-packets
#bpf "bpf-ip" "tcp" "tcp" 
#bpf-next "udp" "udp" 
#bpf-next "icmp" "icmp" 
# would have extra in it, as no label
#bpf-bytes

# count pkts of type tcp/udp/icmp/ip
# not just bytes
bpf-packets
bpf "protopkts" "ip" "ip"
bpf-next "tcp" "tcp"
bpf-next "udp" "udp"
bpf-next "icmp" "icmp"
bpf-bytes

# example 3: distinquish packets you send to the Inet from packets
# you receive from the Internet.
# assume you are class B address 172.16/16 in this example.  We leave
# multicast entirely out in order to focus on unicast.
#bpf "bpf-inout" "in" "not multicast and dst net 172.16.0.0/16 and not src net 172.16.0.0/16"
#bpf-next "out" "not multicast and src net 172.16.0.0/16 and not dst net 172.16.0.0/16"
#bpf-noxtra

# bpf "ports of interest"
# we show ssh vs (some) p2p, vs web, vs ftp vs email traffic
# remainder traffic is ignored.
# p2p ports are approximate.  this could be tuned
# by watching the topn ports list over time.
#
bpf "ports" "ssh" "tcp port 22"
bpf-next "p2p" "port 1214 or port 6881 or port 4662 or port 6346 or port 6257 or port 6699 or port 6257"
bpf-next "web" "tcp port 80 or tcp port 443"
bpf-next "ftp" "tcp port 20 or tcp port 21"
bpf-next "email" "tcp port 25"
bpf-noxtra

# vpn/tunnel graphs
bpf "vpntuns" "esp" "ip proto 50"
bpf-next "ah" "ip proto 51"
bpf-next "ipip" "ip proto 4 or ip proto 94"
#likely to be microsoft PPTP
bpf-next "CiscoGRE" "ip proto 47"
bpf-noxtra

# the following bpf graphs may be of use in catching
# DOS attacks and other funny business
# network errors
# tcp resets vs icmpunreachables vs pings vs icmp time exceeded
bpf-packets
bpf "errors" "tcprst" "tcp[tcpflags] & tcp-rst != 0"
bpf-next "icmpunreach" "icmp[icmptype] == icmp-unreach"
bpf-next "icmpping" "(icmp[icmptype] == icmp-echoreply) || (icmp[icmptype] == icmp-echo)"
bpf-next "icmptimxceed" "icmp[icmptype] == icmp-timxceed"
bpf-noxtra
bpf-bytes

# breakdown of net unreachable above to things that actually
# appear in the real world
#0 - net unreachable
#1 - host unreachable
#3 - port unreachable
#12 - admin prohibited
# icmp port unreachables
bpf-packets
bpf "icmpunreach" "net" "icmp[icmptype] == icmp-unreach && icmp[icmpcode] == 0"
bpf-next "host" "icmp[icmptype] == icmp-unreach && icmp[icmpcode] == 1"
bpf-next "port" "icmp[icmptype] == icmp-unreach && icmp[icmpcode] == 3"
bpf-next "adminprohibit" "icmp[icmptype] == icmp-unreach && icmp[icmpcode] == 13"
bpf-noxtra
bpf-bytes

# tcp control packets.  this graph is very useful for baselining
# tcp syn attacks and scanning
bpf-packets
bpf "tcpcontrol" "rst" "tcp[tcpflags] & tcp-rst != 0"
bpf-next  "syn" "tcp[tcpflags] & tcp-syn != 0"
bpf-next "fin" "tcp[tcpflags] & tcp-fin != 0"
bpf-noxtra
bpf-bytes

# watch p2p activity

bpf "p2pvsworld" "kazaaetc" "port 1214"
# bittorrent: 6881:6889
bpf-next "bittorrent" "tcp and (port 6881 or port 6882 or port 6883 or port 6884 or port 6885 or port 6886 or port 6887 or port 6888 or port 6889)"
# edonkey 4661, 4662, 4665, tcp for all 3, udp for the last
bpf-next "edonkey" "(udp and port 4665) or (tcp and (port 4665 or port 4661 or port 4662))"
bpf-next "gnutella" "port 6346 or port 6347"
bpf-next "winmx" "(tcp and port 6699) or (udp and port 6257)"
bpf-noxtra

